# Generated from ccedilha.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3,")
        buf.write("\u0109\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\3\2\3\2\7\2%\n\2\f")
        buf.write("\2\16\2(\13\2\3\3\3\3\3\3\3\3\3\3\3\4\3\4\3\4\5\4\62\n")
        buf.write("\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4:\n\4\3\4\3\4\3\5\3\5\3")
        buf.write("\5\3\5\3\5\3\5\3\5\3\5\7\5F\n\5\f\5\16\5I\13\5\3\6\3\6")
        buf.write("\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\5\6Y")
        buf.write("\n\6\3\7\3\7\3\7\3\7\3\7\3\b\3\b\3\t\3\t\3\n\3\n\3\n\3")
        buf.write("\n\3\n\3\n\5\nj\n\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3")
        buf.write("\n\3\n\3\n\3\n\6\nx\n\n\r\n\16\ny\3\n\3\n\3\n\3\n\3\n")
        buf.write("\3\n\3\n\3\n\5\n\u0084\n\n\3\13\3\13\3\13\5\13\u0089\n")
        buf.write("\13\3\13\3\13\3\13\6\13\u008e\n\13\r\13\16\13\u008f\3")
        buf.write("\13\3\13\5\13\u0094\n\13\3\13\3\13\3\f\3\f\5\f\u009a\n")
        buf.write("\f\3\f\3\f\3\f\3\f\3\f\5\f\u00a1\n\f\3\f\5\f\u00a4\n\f")
        buf.write("\3\f\3\f\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\5")
        buf.write("\r\u00b3\n\r\3\16\3\16\3\16\3\16\5\16\u00b9\n\16\3\17")
        buf.write("\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17")
        buf.write("\3\17\3\17\5\17\u00c9\n\17\3\17\3\17\3\17\3\17\3\17\3")
        buf.write("\17\3\17\3\17\5\17\u00d3\n\17\3\20\3\20\3\20\3\20\3\20")
        buf.write("\3\20\5\20\u00db\n\20\3\20\3\20\5\20\u00df\n\20\3\20\3")
        buf.write("\20\3\20\5\20\u00e4\n\20\3\20\5\20\u00e7\n\20\3\20\5\20")
        buf.write("\u00ea\n\20\3\20\3\20\3\20\7\20\u00ef\n\20\f\20\16\20")
        buf.write("\u00f2\13\20\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\5")
        buf.write("\21\u00fc\n\21\3\21\3\21\3\21\3\21\3\21\3\21\7\21\u0104")
        buf.write("\n\21\f\21\16\21\u0107\13\21\3\21\2\4\36 \22\2\4\6\b\n")
        buf.write("\f\16\20\22\24\26\30\32\34\36 \2\b\3\2\7\13\5\2\f\f\16")
        buf.write("\16\24\27\4\2\"#&&\3\2\22\23\3\2\34\36\3\2\32\33\2\u0128")
        buf.write("\2\"\3\2\2\2\4)\3\2\2\2\6\61\3\2\2\2\bG\3\2\2\2\nX\3\2")
        buf.write("\2\2\fZ\3\2\2\2\16_\3\2\2\2\20a\3\2\2\2\22\u0083\3\2\2")
        buf.write("\2\24\u0085\3\2\2\2\26\u0097\3\2\2\2\30\u00b2\3\2\2\2")
        buf.write("\32\u00b8\3\2\2\2\34\u00d2\3\2\2\2\36\u00e9\3\2\2\2 \u00fb")
        buf.write("\3\2\2\2\"&\5\4\3\2#%\5\22\n\2$#\3\2\2\2%(\3\2\2\2&$\3")
        buf.write("\2\2\2&\'\3\2\2\2\'\3\3\2\2\2(&\3\2\2\2)*\7\3\2\2*+\7")
        buf.write(")\2\2+,\5\b\5\2,-\7*\2\2-\5\3\2\2\2.\62\5\n\6\2/\62\7")
        buf.write("&\2\2\60\62\5\f\7\2\61.\3\2\2\2\61/\3\2\2\2\61\60\3\2")
        buf.write("\2\2\62\63\3\2\2\2\639\7\r\2\2\64:\5 \21\2\65:\7#\2\2")
        buf.write("\66:\5\36\20\2\67:\7&\2\28:\5\24\13\29\64\3\2\2\29\65")
        buf.write("\3\2\2\29\66\3\2\2\29\67\3\2\2\298\3\2\2\2:;\3\2\2\2;")
        buf.write("<\7!\2\2<\7\3\2\2\2=F\5\30\r\2>F\5\6\4\2?F\5\n\6\2@F\5")
        buf.write("\34\17\2AB\5\24\13\2BC\7!\2\2CF\3\2\2\2DF\5\26\f\2E=\3")
        buf.write("\2\2\2E>\3\2\2\2E?\3\2\2\2E@\3\2\2\2EA\3\2\2\2ED\3\2\2")
        buf.write("\2FI\3\2\2\2GE\3\2\2\2GH\3\2\2\2H\t\3\2\2\2IG\3\2\2\2")
        buf.write("JK\5\16\b\2KL\7&\2\2LY\3\2\2\2MN\5\16\b\2NO\7&\2\2OP\7")
        buf.write("!\2\2PY\3\2\2\2QR\5\16\b\2RS\5\f\7\2SY\3\2\2\2TU\5\16")
        buf.write("\b\2UV\5\f\7\2VW\7!\2\2WY\3\2\2\2XJ\3\2\2\2XM\3\2\2\2")
        buf.write("XQ\3\2\2\2XT\3\2\2\2Y\13\3\2\2\2Z[\7&\2\2[\\\7\'\2\2\\")
        buf.write("]\7\"\2\2]^\7(\2\2^\r\3\2\2\2_`\t\2\2\2`\17\3\2\2\2ab")
        buf.write("\t\3\2\2b\21\3\2\2\2cd\5\16\b\2de\7&\2\2ei\7+\2\2fg\5")
        buf.write("\16\b\2gh\7&\2\2hj\3\2\2\2if\3\2\2\2ij\3\2\2\2jk\3\2\2")
        buf.write("\2kl\7,\2\2lm\7)\2\2mn\5\b\5\2no\7*\2\2o\u0084\3\2\2\2")
        buf.write("pq\5\16\b\2qr\7&\2\2rw\7+\2\2st\5\16\b\2tu\7&\2\2uv\7")
        buf.write("\4\2\2vx\3\2\2\2ws\3\2\2\2xy\3\2\2\2yw\3\2\2\2yz\3\2\2")
        buf.write("\2z{\3\2\2\2{|\5\16\b\2|}\7&\2\2}~\3\2\2\2~\177\7,\2\2")
        buf.write("\177\u0080\7)\2\2\u0080\u0081\5\b\5\2\u0081\u0082\7*\2")
        buf.write("\2\u0082\u0084\3\2\2\2\u0083c\3\2\2\2\u0083p\3\2\2\2\u0084")
        buf.write("\23\3\2\2\2\u0085\u0086\7&\2\2\u0086\u0093\7+\2\2\u0087")
        buf.write("\u0089\5\32\16\2\u0088\u0087\3\2\2\2\u0088\u0089\3\2\2")
        buf.write("\2\u0089\u0094\3\2\2\2\u008a\u008b\5\32\16\2\u008b\u008c")
        buf.write("\7\4\2\2\u008c\u008e\3\2\2\2\u008d\u008a\3\2\2\2\u008e")
        buf.write("\u008f\3\2\2\2\u008f\u008d\3\2\2\2\u008f\u0090\3\2\2\2")
        buf.write("\u0090\u0091\3\2\2\2\u0091\u0092\5\32\16\2\u0092\u0094")
        buf.write("\3\2\2\2\u0093\u0088\3\2\2\2\u0093\u008d\3\2\2\2\u0094")
        buf.write("\u0095\3\2\2\2\u0095\u0096\7,\2\2\u0096\25\3\2\2\2\u0097")
        buf.write("\u0099\7\31\2\2\u0098\u009a\7+\2\2\u0099\u0098\3\2\2\2")
        buf.write("\u0099\u009a\3\2\2\2\u009a\u00a0\3\2\2\2\u009b\u00a1\5")
        buf.write(" \21\2\u009c\u00a1\7#\2\2\u009d\u00a1\5\36\20\2\u009e")
        buf.write("\u00a1\7&\2\2\u009f\u00a1\5\24\13\2\u00a0\u009b\3\2\2")
        buf.write("\2\u00a0\u009c\3\2\2\2\u00a0\u009d\3\2\2\2\u00a0\u009e")
        buf.write("\3\2\2\2\u00a0\u009f\3\2\2\2\u00a1\u00a3\3\2\2\2\u00a2")
        buf.write("\u00a4\7,\2\2\u00a3\u00a2\3\2\2\2\u00a3\u00a4\3\2\2\2")
        buf.write("\u00a4\u00a5\3\2\2\2\u00a5\u00a6\7!\2\2\u00a6\27\3\2\2")
        buf.write("\2\u00a7\u00a8\7\5\2\2\u00a8\u00a9\7+\2\2\u00a9\u00aa")
        buf.write("\t\4\2\2\u00aa\u00ab\7,\2\2\u00ab\u00b3\7!\2\2\u00ac\u00ad")
        buf.write("\7&\2\2\u00ad\u00ae\7\37\2\2\u00ae\u00b3\7!\2\2\u00af")
        buf.write("\u00b0\7&\2\2\u00b0\u00b1\7 \2\2\u00b1\u00b3\7!\2\2\u00b2")
        buf.write("\u00a7\3\2\2\2\u00b2\u00ac\3\2\2\2\u00b2\u00af\3\2\2\2")
        buf.write("\u00b3\31\3\2\2\2\u00b4\u00b9\5 \21\2\u00b5\u00b9\7#\2")
        buf.write("\2\u00b6\u00b9\5\36\20\2\u00b7\u00b9\7&\2\2\u00b8\u00b4")
        buf.write("\3\2\2\2\u00b8\u00b5\3\2\2\2\u00b8\u00b6\3\2\2\2\u00b8")
        buf.write("\u00b7\3\2\2\2\u00b9\33\3\2\2\2\u00ba\u00bb\7\17\2\2\u00bb")
        buf.write("\u00bc\7+\2\2\u00bc\u00bd\5\36\20\2\u00bd\u00be\7,\2\2")
        buf.write("\u00be\u00bf\7)\2\2\u00bf\u00c0\5\b\5\2\u00c0\u00c8\7")
        buf.write("*\2\2\u00c1\u00c2\7\20\2\2\u00c2\u00c9\5\34\17\2\u00c3")
        buf.write("\u00c4\7\20\2\2\u00c4\u00c5\7)\2\2\u00c5\u00c6\5\b\5\2")
        buf.write("\u00c6\u00c7\7*\2\2\u00c7\u00c9\3\2\2\2\u00c8\u00c1\3")
        buf.write("\2\2\2\u00c8\u00c3\3\2\2\2\u00c8\u00c9\3\2\2\2\u00c9\u00d3")
        buf.write("\3\2\2\2\u00ca\u00cb\7\21\2\2\u00cb\u00cc\7+\2\2\u00cc")
        buf.write("\u00cd\5\36\20\2\u00cd\u00ce\7,\2\2\u00ce\u00cf\7)\2\2")
        buf.write("\u00cf\u00d0\5\b\5\2\u00d0\u00d1\7*\2\2\u00d1\u00d3\3")
        buf.write("\2\2\2\u00d2\u00ba\3\2\2\2\u00d2\u00ca\3\2\2\2\u00d3\35")
        buf.write("\3\2\2\2\u00d4\u00d5\b\20\1\2\u00d5\u00d6\7+\2\2\u00d6")
        buf.write("\u00d7\5\36\20\2\u00d7\u00d8\7,\2\2\u00d8\u00ea\3\2\2")
        buf.write("\2\u00d9\u00db\7\30\2\2\u00da\u00d9\3\2\2\2\u00da\u00db")
        buf.write("\3\2\2\2\u00db\u00de\3\2\2\2\u00dc\u00df\5 \21\2\u00dd")
        buf.write("\u00df\7#\2\2\u00de\u00dc\3\2\2\2\u00de\u00dd\3\2\2\2")
        buf.write("\u00df\u00e0\3\2\2\2\u00e0\u00e3\5\20\t\2\u00e1\u00e4")
        buf.write("\5 \21\2\u00e2\u00e4\7#\2\2\u00e3\u00e1\3\2\2\2\u00e3")
        buf.write("\u00e2\3\2\2\2\u00e4\u00ea\3\2\2\2\u00e5\u00e7\7\30\2")
        buf.write("\2\u00e6\u00e5\3\2\2\2\u00e6\u00e7\3\2\2\2\u00e7\u00e8")
        buf.write("\3\2\2\2\u00e8\u00ea\7%\2\2\u00e9\u00d4\3\2\2\2\u00e9")
        buf.write("\u00da\3\2\2\2\u00e9\u00e6\3\2\2\2\u00ea\u00f0\3\2\2\2")
        buf.write("\u00eb\u00ec\f\6\2\2\u00ec\u00ed\t\5\2\2\u00ed\u00ef\5")
        buf.write("\36\20\7\u00ee\u00eb\3\2\2\2\u00ef\u00f2\3\2\2\2\u00f0")
        buf.write("\u00ee\3\2\2\2\u00f0\u00f1\3\2\2\2\u00f1\37\3\2\2\2\u00f2")
        buf.write("\u00f0\3\2\2\2\u00f3\u00f4\b\21\1\2\u00f4\u00fc\7\"\2")
        buf.write("\2\u00f5\u00fc\7&\2\2\u00f6\u00fc\5\24\13\2\u00f7\u00f8")
        buf.write("\7+\2\2\u00f8\u00f9\5 \21\2\u00f9\u00fa\7,\2\2\u00fa\u00fc")
        buf.write("\3\2\2\2\u00fb\u00f3\3\2\2\2\u00fb\u00f5\3\2\2\2\u00fb")
        buf.write("\u00f6\3\2\2\2\u00fb\u00f7\3\2\2\2\u00fc\u0105\3\2\2\2")
        buf.write("\u00fd\u00fe\f\b\2\2\u00fe\u00ff\t\6\2\2\u00ff\u0104\5")
        buf.write(" \21\t\u0100\u0101\f\7\2\2\u0101\u0102\t\7\2\2\u0102\u0104")
        buf.write("\5 \21\b\u0103\u00fd\3\2\2\2\u0103\u0100\3\2\2\2\u0104")
        buf.write("\u0107\3\2\2\2\u0105\u0103\3\2\2\2\u0105\u0106\3\2\2\2")
        buf.write("\u0106!\3\2\2\2\u0107\u0105\3\2\2\2\36&\619EGXiy\u0083")
        buf.write("\u0088\u008f\u0093\u0099\u00a0\u00a3\u00b2\u00b8\u00c8")
        buf.write("\u00d2\u00da\u00de\u00e3\u00e6\u00e9\u00f0\u00fb\u0103")
        buf.write("\u0105")
        return buf.getvalue()


class ccedilhaParser ( Parser ):

    grammarFileName = "ccedilha.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'nada principal()'", "','", "'amostrar'", 
                     "<INVALID>", "'inteiro '", "'sentenca '", "'flutuante '", 
                     "'talvez '", "'letra '", "' diferente '", "' igual '", 
                     "' igualIgual '", "'se'", "'senao'", "'enquanto'", 
                     "' e '", "' ou '", "' maiorIgual '", "' menorIgual '", 
                     "' maior '", "' menor '", "'nao '", "'volte '", "' mais '", 
                     "' menos '", "' vezes '", "' divide '", "' resto '", 
                     "' maisMais'", "' menosMenos'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'['", "']'", "'{'", "'}'", "'('", "')'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "WS", "DEINT", "DESTRING", "DEFLOAT", "DEBOOL", "DECHAR", 
                      "NOT_EQUAL", "EQUAL", "EQUAL_EQUAL", "IF", "ELSE", 
                      "WHILE", "AND", "OR", "GREATER_EQUAL", "LESSER_EQUAL", 
                      "GREATER", "LESSER", "NOT", "RETURN", "PLUS", "MINUS", 
                      "MULT", "DIV", "REST", "PLUS_PLUS", "MINUS_MINUS", 
                      "ENDLINE", "INT", "STRING", "FLOAT", "BOOL", "ID", 
                      "LBOX", "RBOX", "LKEY", "RKEY", "LPAREN", "RPAREN" ]

    RULE_prog = 0
    RULE_main = 1
    RULE_att = 2
    RULE_code = 3
    RULE_dec = 4
    RULE_list_type = 5
    RULE_basic_type = 6
    RULE_basic_logic = 7
    RULE_func_dec = 8
    RULE_func_call = 9
    RULE_func_end = 10
    RULE_func = 11
    RULE_args = 12
    RULE_boolean = 13
    RULE_expr_bool = 14
    RULE_expr = 15

    ruleNames =  [ "prog", "main", "att", "code", "dec", "list_type", "basic_type", 
                   "basic_logic", "func_dec", "func_call", "func_end", "func", 
                   "args", "boolean", "expr_bool", "expr" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    WS=4
    DEINT=5
    DESTRING=6
    DEFLOAT=7
    DEBOOL=8
    DECHAR=9
    NOT_EQUAL=10
    EQUAL=11
    EQUAL_EQUAL=12
    IF=13
    ELSE=14
    WHILE=15
    AND=16
    OR=17
    GREATER_EQUAL=18
    LESSER_EQUAL=19
    GREATER=20
    LESSER=21
    NOT=22
    RETURN=23
    PLUS=24
    MINUS=25
    MULT=26
    DIV=27
    REST=28
    PLUS_PLUS=29
    MINUS_MINUS=30
    ENDLINE=31
    INT=32
    STRING=33
    FLOAT=34
    BOOL=35
    ID=36
    LBOX=37
    RBOX=38
    LKEY=39
    RKEY=40
    LPAREN=41
    RPAREN=42

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def main(self):
            return self.getTypedRuleContext(ccedilhaParser.MainContext,0)


        def func_dec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ccedilhaParser.Func_decContext)
            else:
                return self.getTypedRuleContext(ccedilhaParser.Func_decContext,i)


        def getRuleIndex(self):
            return ccedilhaParser.RULE_prog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg" ):
                listener.enterProg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg" ):
                listener.exitProg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProg" ):
                return visitor.visitProg(self)
            else:
                return visitor.visitChildren(self)




    def prog(self):

        localctx = ccedilhaParser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 32
            self.main()
            self.state = 36
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ccedilhaParser.DEINT) | (1 << ccedilhaParser.DESTRING) | (1 << ccedilhaParser.DEFLOAT) | (1 << ccedilhaParser.DEBOOL) | (1 << ccedilhaParser.DECHAR))) != 0):
                self.state = 33
                self.func_dec()
                self.state = 38
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MainContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LKEY(self):
            return self.getToken(ccedilhaParser.LKEY, 0)

        def code(self):
            return self.getTypedRuleContext(ccedilhaParser.CodeContext,0)


        def RKEY(self):
            return self.getToken(ccedilhaParser.RKEY, 0)

        def getRuleIndex(self):
            return ccedilhaParser.RULE_main

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMain" ):
                listener.enterMain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMain" ):
                listener.exitMain(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMain" ):
                return visitor.visitMain(self)
            else:
                return visitor.visitChildren(self)




    def main(self):

        localctx = ccedilhaParser.MainContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_main)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 39
            self.match(ccedilhaParser.T__0)
            self.state = 40
            self.match(ccedilhaParser.LKEY)
            self.state = 41
            self.code()
            self.state = 42
            self.match(ccedilhaParser.RKEY)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(ccedilhaParser.EQUAL, 0)

        def ENDLINE(self):
            return self.getToken(ccedilhaParser.ENDLINE, 0)

        def dec(self):
            return self.getTypedRuleContext(ccedilhaParser.DecContext,0)


        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(ccedilhaParser.ID)
            else:
                return self.getToken(ccedilhaParser.ID, i)

        def list_type(self):
            return self.getTypedRuleContext(ccedilhaParser.List_typeContext,0)


        def expr(self):
            return self.getTypedRuleContext(ccedilhaParser.ExprContext,0)


        def STRING(self):
            return self.getToken(ccedilhaParser.STRING, 0)

        def expr_bool(self):
            return self.getTypedRuleContext(ccedilhaParser.Expr_boolContext,0)


        def func_call(self):
            return self.getTypedRuleContext(ccedilhaParser.Func_callContext,0)


        def getRuleIndex(self):
            return ccedilhaParser.RULE_att

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtt" ):
                listener.enterAtt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtt" ):
                listener.exitAtt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtt" ):
                return visitor.visitAtt(self)
            else:
                return visitor.visitChildren(self)




    def att(self):

        localctx = ccedilhaParser.AttContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_att)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 47
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 44
                self.dec()
                pass

            elif la_ == 2:
                self.state = 45
                self.match(ccedilhaParser.ID)
                pass

            elif la_ == 3:
                self.state = 46
                self.list_type()
                pass


            self.state = 49
            self.match(ccedilhaParser.EQUAL)
            self.state = 55
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.state = 50
                self.expr(0)
                pass

            elif la_ == 2:
                self.state = 51
                self.match(ccedilhaParser.STRING)
                pass

            elif la_ == 3:
                self.state = 52
                self.expr_bool(0)
                pass

            elif la_ == 4:
                self.state = 53
                self.match(ccedilhaParser.ID)
                pass

            elif la_ == 5:
                self.state = 54
                self.func_call()
                pass


            self.state = 57
            self.match(ccedilhaParser.ENDLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CodeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def func(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ccedilhaParser.FuncContext)
            else:
                return self.getTypedRuleContext(ccedilhaParser.FuncContext,i)


        def att(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ccedilhaParser.AttContext)
            else:
                return self.getTypedRuleContext(ccedilhaParser.AttContext,i)


        def dec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ccedilhaParser.DecContext)
            else:
                return self.getTypedRuleContext(ccedilhaParser.DecContext,i)


        def boolean(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ccedilhaParser.BooleanContext)
            else:
                return self.getTypedRuleContext(ccedilhaParser.BooleanContext,i)


        def func_call(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ccedilhaParser.Func_callContext)
            else:
                return self.getTypedRuleContext(ccedilhaParser.Func_callContext,i)


        def ENDLINE(self, i:int=None):
            if i is None:
                return self.getTokens(ccedilhaParser.ENDLINE)
            else:
                return self.getToken(ccedilhaParser.ENDLINE, i)

        def func_end(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ccedilhaParser.Func_endContext)
            else:
                return self.getTypedRuleContext(ccedilhaParser.Func_endContext,i)


        def getRuleIndex(self):
            return ccedilhaParser.RULE_code

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCode" ):
                listener.enterCode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCode" ):
                listener.exitCode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCode" ):
                return visitor.visitCode(self)
            else:
                return visitor.visitChildren(self)




    def code(self):

        localctx = ccedilhaParser.CodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_code)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ccedilhaParser.T__2) | (1 << ccedilhaParser.DEINT) | (1 << ccedilhaParser.DESTRING) | (1 << ccedilhaParser.DEFLOAT) | (1 << ccedilhaParser.DEBOOL) | (1 << ccedilhaParser.DECHAR) | (1 << ccedilhaParser.IF) | (1 << ccedilhaParser.WHILE) | (1 << ccedilhaParser.RETURN) | (1 << ccedilhaParser.ID))) != 0):
                self.state = 67
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
                if la_ == 1:
                    self.state = 59
                    self.func()
                    pass

                elif la_ == 2:
                    self.state = 60
                    self.att()
                    pass

                elif la_ == 3:
                    self.state = 61
                    self.dec()
                    pass

                elif la_ == 4:
                    self.state = 62
                    self.boolean()
                    pass

                elif la_ == 5:
                    self.state = 63
                    self.func_call()
                    self.state = 64
                    self.match(ccedilhaParser.ENDLINE)
                    pass

                elif la_ == 6:
                    self.state = 66
                    self.func_end()
                    pass


                self.state = 71
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basic_type(self):
            return self.getTypedRuleContext(ccedilhaParser.Basic_typeContext,0)


        def ID(self):
            return self.getToken(ccedilhaParser.ID, 0)

        def ENDLINE(self):
            return self.getToken(ccedilhaParser.ENDLINE, 0)

        def list_type(self):
            return self.getTypedRuleContext(ccedilhaParser.List_typeContext,0)


        def getRuleIndex(self):
            return ccedilhaParser.RULE_dec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDec" ):
                listener.enterDec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDec" ):
                listener.exitDec(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDec" ):
                return visitor.visitDec(self)
            else:
                return visitor.visitChildren(self)




    def dec(self):

        localctx = ccedilhaParser.DecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_dec)
        try:
            self.state = 86
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 72
                self.basic_type()
                self.state = 73
                self.match(ccedilhaParser.ID)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 75
                self.basic_type()
                self.state = 76
                self.match(ccedilhaParser.ID)
                self.state = 77
                self.match(ccedilhaParser.ENDLINE)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 79
                self.basic_type()
                self.state = 80
                self.list_type()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 82
                self.basic_type()
                self.state = 83
                self.list_type()
                self.state = 84
                self.match(ccedilhaParser.ENDLINE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class List_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(ccedilhaParser.ID, 0)

        def LBOX(self):
            return self.getToken(ccedilhaParser.LBOX, 0)

        def INT(self):
            return self.getToken(ccedilhaParser.INT, 0)

        def RBOX(self):
            return self.getToken(ccedilhaParser.RBOX, 0)

        def getRuleIndex(self):
            return ccedilhaParser.RULE_list_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterList_type" ):
                listener.enterList_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitList_type" ):
                listener.exitList_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitList_type" ):
                return visitor.visitList_type(self)
            else:
                return visitor.visitChildren(self)




    def list_type(self):

        localctx = ccedilhaParser.List_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_list_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 88
            self.match(ccedilhaParser.ID)
            self.state = 89
            self.match(ccedilhaParser.LBOX)
            self.state = 90
            self.match(ccedilhaParser.INT)
            self.state = 91
            self.match(ccedilhaParser.RBOX)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Basic_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEINT(self):
            return self.getToken(ccedilhaParser.DEINT, 0)

        def DESTRING(self):
            return self.getToken(ccedilhaParser.DESTRING, 0)

        def DEFLOAT(self):
            return self.getToken(ccedilhaParser.DEFLOAT, 0)

        def DEBOOL(self):
            return self.getToken(ccedilhaParser.DEBOOL, 0)

        def DECHAR(self):
            return self.getToken(ccedilhaParser.DECHAR, 0)

        def getRuleIndex(self):
            return ccedilhaParser.RULE_basic_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasic_type" ):
                listener.enterBasic_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasic_type" ):
                listener.exitBasic_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasic_type" ):
                return visitor.visitBasic_type(self)
            else:
                return visitor.visitChildren(self)




    def basic_type(self):

        localctx = ccedilhaParser.Basic_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_basic_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ccedilhaParser.DEINT) | (1 << ccedilhaParser.DESTRING) | (1 << ccedilhaParser.DEFLOAT) | (1 << ccedilhaParser.DEBOOL) | (1 << ccedilhaParser.DECHAR))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Basic_logicContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOT_EQUAL(self):
            return self.getToken(ccedilhaParser.NOT_EQUAL, 0)

        def EQUAL_EQUAL(self):
            return self.getToken(ccedilhaParser.EQUAL_EQUAL, 0)

        def GREATER(self):
            return self.getToken(ccedilhaParser.GREATER, 0)

        def GREATER_EQUAL(self):
            return self.getToken(ccedilhaParser.GREATER_EQUAL, 0)

        def LESSER_EQUAL(self):
            return self.getToken(ccedilhaParser.LESSER_EQUAL, 0)

        def LESSER(self):
            return self.getToken(ccedilhaParser.LESSER, 0)

        def getRuleIndex(self):
            return ccedilhaParser.RULE_basic_logic

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasic_logic" ):
                listener.enterBasic_logic(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasic_logic" ):
                listener.exitBasic_logic(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBasic_logic" ):
                return visitor.visitBasic_logic(self)
            else:
                return visitor.visitChildren(self)




    def basic_logic(self):

        localctx = ccedilhaParser.Basic_logicContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_basic_logic)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 95
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ccedilhaParser.NOT_EQUAL) | (1 << ccedilhaParser.EQUAL_EQUAL) | (1 << ccedilhaParser.GREATER_EQUAL) | (1 << ccedilhaParser.LESSER_EQUAL) | (1 << ccedilhaParser.GREATER) | (1 << ccedilhaParser.LESSER))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Func_decContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def basic_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ccedilhaParser.Basic_typeContext)
            else:
                return self.getTypedRuleContext(ccedilhaParser.Basic_typeContext,i)


        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(ccedilhaParser.ID)
            else:
                return self.getToken(ccedilhaParser.ID, i)

        def LPAREN(self):
            return self.getToken(ccedilhaParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(ccedilhaParser.RPAREN, 0)

        def LKEY(self):
            return self.getToken(ccedilhaParser.LKEY, 0)

        def code(self):
            return self.getTypedRuleContext(ccedilhaParser.CodeContext,0)


        def RKEY(self):
            return self.getToken(ccedilhaParser.RKEY, 0)

        def getRuleIndex(self):
            return ccedilhaParser.RULE_func_dec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_dec" ):
                listener.enterFunc_dec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_dec" ):
                listener.exitFunc_dec(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunc_dec" ):
                return visitor.visitFunc_dec(self)
            else:
                return visitor.visitChildren(self)




    def func_dec(self):

        localctx = ccedilhaParser.Func_decContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_func_dec)
        self._la = 0 # Token type
        try:
            self.state = 129
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 97
                self.basic_type()
                self.state = 98
                self.match(ccedilhaParser.ID)
                self.state = 99
                self.match(ccedilhaParser.LPAREN)
                self.state = 103
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ccedilhaParser.DEINT) | (1 << ccedilhaParser.DESTRING) | (1 << ccedilhaParser.DEFLOAT) | (1 << ccedilhaParser.DEBOOL) | (1 << ccedilhaParser.DECHAR))) != 0):
                    self.state = 100
                    self.basic_type()
                    self.state = 101
                    self.match(ccedilhaParser.ID)


                self.state = 105
                self.match(ccedilhaParser.RPAREN)
                self.state = 106
                self.match(ccedilhaParser.LKEY)
                self.state = 107
                self.code()
                self.state = 108
                self.match(ccedilhaParser.RKEY)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 110
                self.basic_type()
                self.state = 111
                self.match(ccedilhaParser.ID)
                self.state = 112
                self.match(ccedilhaParser.LPAREN)
                self.state = 117 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 113
                        self.basic_type()
                        self.state = 114
                        self.match(ccedilhaParser.ID)
                        self.state = 115
                        self.match(ccedilhaParser.T__1)

                    else:
                        raise NoViableAltException(self)
                    self.state = 119 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

                self.state = 121
                self.basic_type()
                self.state = 122
                self.match(ccedilhaParser.ID)
                self.state = 124
                self.match(ccedilhaParser.RPAREN)
                self.state = 125
                self.match(ccedilhaParser.LKEY)
                self.state = 126
                self.code()
                self.state = 127
                self.match(ccedilhaParser.RKEY)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Func_callContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(ccedilhaParser.ID, 0)

        def LPAREN(self):
            return self.getToken(ccedilhaParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(ccedilhaParser.RPAREN, 0)

        def args(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ccedilhaParser.ArgsContext)
            else:
                return self.getTypedRuleContext(ccedilhaParser.ArgsContext,i)


        def getRuleIndex(self):
            return ccedilhaParser.RULE_func_call

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_call" ):
                listener.enterFunc_call(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_call" ):
                listener.exitFunc_call(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunc_call" ):
                return visitor.visitFunc_call(self)
            else:
                return visitor.visitChildren(self)




    def func_call(self):

        localctx = ccedilhaParser.Func_callContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_func_call)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            self.match(ccedilhaParser.ID)
            self.state = 132
            self.match(ccedilhaParser.LPAREN)
            self.state = 145
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.state = 134
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ccedilhaParser.NOT) | (1 << ccedilhaParser.INT) | (1 << ccedilhaParser.STRING) | (1 << ccedilhaParser.BOOL) | (1 << ccedilhaParser.ID) | (1 << ccedilhaParser.LPAREN))) != 0):
                    self.state = 133
                    self.args()


                pass

            elif la_ == 2:
                self.state = 139 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 136
                        self.args()
                        self.state = 137
                        self.match(ccedilhaParser.T__1)

                    else:
                        raise NoViableAltException(self)
                    self.state = 141 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

                self.state = 143
                self.args()
                pass


            self.state = 147
            self.match(ccedilhaParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Func_endContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(ccedilhaParser.RETURN, 0)

        def ENDLINE(self):
            return self.getToken(ccedilhaParser.ENDLINE, 0)

        def expr(self):
            return self.getTypedRuleContext(ccedilhaParser.ExprContext,0)


        def STRING(self):
            return self.getToken(ccedilhaParser.STRING, 0)

        def expr_bool(self):
            return self.getTypedRuleContext(ccedilhaParser.Expr_boolContext,0)


        def ID(self):
            return self.getToken(ccedilhaParser.ID, 0)

        def func_call(self):
            return self.getTypedRuleContext(ccedilhaParser.Func_callContext,0)


        def LPAREN(self):
            return self.getToken(ccedilhaParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(ccedilhaParser.RPAREN, 0)

        def getRuleIndex(self):
            return ccedilhaParser.RULE_func_end

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_end" ):
                listener.enterFunc_end(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_end" ):
                listener.exitFunc_end(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunc_end" ):
                return visitor.visitFunc_end(self)
            else:
                return visitor.visitChildren(self)




    def func_end(self):

        localctx = ccedilhaParser.Func_endContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_func_end)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 149
            self.match(ccedilhaParser.RETURN)
            self.state = 151
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.state = 150
                self.match(ccedilhaParser.LPAREN)


            self.state = 158
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.state = 153
                self.expr(0)
                pass

            elif la_ == 2:
                self.state = 154
                self.match(ccedilhaParser.STRING)
                pass

            elif la_ == 3:
                self.state = 155
                self.expr_bool(0)
                pass

            elif la_ == 4:
                self.state = 156
                self.match(ccedilhaParser.ID)
                pass

            elif la_ == 5:
                self.state = 157
                self.func_call()
                pass


            self.state = 161
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ccedilhaParser.RPAREN:
                self.state = 160
                self.match(ccedilhaParser.RPAREN)


            self.state = 163
            self.match(ccedilhaParser.ENDLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ccedilhaParser.RULE_func

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class FuncMinusMinusContext(FuncContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ccedilhaParser.FuncContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(ccedilhaParser.ID, 0)
        def MINUS_MINUS(self):
            return self.getToken(ccedilhaParser.MINUS_MINUS, 0)
        def ENDLINE(self):
            return self.getToken(ccedilhaParser.ENDLINE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncMinusMinus" ):
                listener.enterFuncMinusMinus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncMinusMinus" ):
                listener.exitFuncMinusMinus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncMinusMinus" ):
                return visitor.visitFuncMinusMinus(self)
            else:
                return visitor.visitChildren(self)


    class FuncPlusPlusContext(FuncContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ccedilhaParser.FuncContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(ccedilhaParser.ID, 0)
        def PLUS_PLUS(self):
            return self.getToken(ccedilhaParser.PLUS_PLUS, 0)
        def ENDLINE(self):
            return self.getToken(ccedilhaParser.ENDLINE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncPlusPlus" ):
                listener.enterFuncPlusPlus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncPlusPlus" ):
                listener.exitFuncPlusPlus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncPlusPlus" ):
                return visitor.visitFuncPlusPlus(self)
            else:
                return visitor.visitChildren(self)


    class FuncPrintContext(FuncContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ccedilhaParser.FuncContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(ccedilhaParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(ccedilhaParser.RPAREN, 0)
        def ENDLINE(self):
            return self.getToken(ccedilhaParser.ENDLINE, 0)
        def STRING(self):
            return self.getToken(ccedilhaParser.STRING, 0)
        def INT(self):
            return self.getToken(ccedilhaParser.INT, 0)
        def ID(self):
            return self.getToken(ccedilhaParser.ID, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncPrint" ):
                listener.enterFuncPrint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncPrint" ):
                listener.exitFuncPrint(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncPrint" ):
                return visitor.visitFuncPrint(self)
            else:
                return visitor.visitChildren(self)



    def func(self):

        localctx = ccedilhaParser.FuncContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_func)
        self._la = 0 # Token type
        try:
            self.state = 176
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                localctx = ccedilhaParser.FuncPrintContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 165
                self.match(ccedilhaParser.T__2)
                self.state = 166
                self.match(ccedilhaParser.LPAREN)
                self.state = 167
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ccedilhaParser.INT) | (1 << ccedilhaParser.STRING) | (1 << ccedilhaParser.ID))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 168
                self.match(ccedilhaParser.RPAREN)
                self.state = 169
                self.match(ccedilhaParser.ENDLINE)
                pass

            elif la_ == 2:
                localctx = ccedilhaParser.FuncPlusPlusContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 170
                self.match(ccedilhaParser.ID)
                self.state = 171
                self.match(ccedilhaParser.PLUS_PLUS)
                self.state = 172
                self.match(ccedilhaParser.ENDLINE)
                pass

            elif la_ == 3:
                localctx = ccedilhaParser.FuncMinusMinusContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 173
                self.match(ccedilhaParser.ID)
                self.state = 174
                self.match(ccedilhaParser.MINUS_MINUS)
                self.state = 175
                self.match(ccedilhaParser.ENDLINE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(ccedilhaParser.ExprContext,0)


        def STRING(self):
            return self.getToken(ccedilhaParser.STRING, 0)

        def expr_bool(self):
            return self.getTypedRuleContext(ccedilhaParser.Expr_boolContext,0)


        def ID(self):
            return self.getToken(ccedilhaParser.ID, 0)

        def getRuleIndex(self):
            return ccedilhaParser.RULE_args

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgs" ):
                listener.enterArgs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgs" ):
                listener.exitArgs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgs" ):
                return visitor.visitArgs(self)
            else:
                return visitor.visitChildren(self)




    def args(self):

        localctx = ccedilhaParser.ArgsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_args)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.state = 178
                self.expr(0)
                pass

            elif la_ == 2:
                self.state = 179
                self.match(ccedilhaParser.STRING)
                pass

            elif la_ == 3:
                self.state = 180
                self.expr_bool(0)
                pass

            elif la_ == 4:
                self.state = 181
                self.match(ccedilhaParser.ID)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(ccedilhaParser.IF, 0)

        def LPAREN(self):
            return self.getToken(ccedilhaParser.LPAREN, 0)

        def expr_bool(self):
            return self.getTypedRuleContext(ccedilhaParser.Expr_boolContext,0)


        def RPAREN(self):
            return self.getToken(ccedilhaParser.RPAREN, 0)

        def LKEY(self, i:int=None):
            if i is None:
                return self.getTokens(ccedilhaParser.LKEY)
            else:
                return self.getToken(ccedilhaParser.LKEY, i)

        def code(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ccedilhaParser.CodeContext)
            else:
                return self.getTypedRuleContext(ccedilhaParser.CodeContext,i)


        def RKEY(self, i:int=None):
            if i is None:
                return self.getTokens(ccedilhaParser.RKEY)
            else:
                return self.getToken(ccedilhaParser.RKEY, i)

        def ELSE(self):
            return self.getToken(ccedilhaParser.ELSE, 0)

        def boolean(self):
            return self.getTypedRuleContext(ccedilhaParser.BooleanContext,0)


        def WHILE(self):
            return self.getToken(ccedilhaParser.WHILE, 0)

        def getRuleIndex(self):
            return ccedilhaParser.RULE_boolean

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolean" ):
                listener.enterBoolean(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolean" ):
                listener.exitBoolean(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolean" ):
                return visitor.visitBoolean(self)
            else:
                return visitor.visitChildren(self)




    def boolean(self):

        localctx = ccedilhaParser.BooleanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_boolean)
        try:
            self.state = 208
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ccedilhaParser.IF]:
                self.enterOuterAlt(localctx, 1)
                self.state = 184
                self.match(ccedilhaParser.IF)
                self.state = 185
                self.match(ccedilhaParser.LPAREN)
                self.state = 186
                self.expr_bool(0)
                self.state = 187
                self.match(ccedilhaParser.RPAREN)
                self.state = 188
                self.match(ccedilhaParser.LKEY)
                self.state = 189
                self.code()
                self.state = 190
                self.match(ccedilhaParser.RKEY)
                self.state = 198
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
                if la_ == 1:
                    self.state = 191
                    self.match(ccedilhaParser.ELSE)
                    self.state = 192
                    self.boolean()

                elif la_ == 2:
                    self.state = 193
                    self.match(ccedilhaParser.ELSE)
                    self.state = 194
                    self.match(ccedilhaParser.LKEY)
                    self.state = 195
                    self.code()
                    self.state = 196
                    self.match(ccedilhaParser.RKEY)


                pass
            elif token in [ccedilhaParser.WHILE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 200
                self.match(ccedilhaParser.WHILE)
                self.state = 201
                self.match(ccedilhaParser.LPAREN)
                self.state = 202
                self.expr_bool(0)
                self.state = 203
                self.match(ccedilhaParser.RPAREN)
                self.state = 204
                self.match(ccedilhaParser.LKEY)
                self.state = 205
                self.code()
                self.state = 206
                self.match(ccedilhaParser.RKEY)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Expr_boolContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ccedilhaParser.RULE_expr_bool

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Expr_boolParenContext(Expr_boolContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ccedilhaParser.Expr_boolContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(ccedilhaParser.LPAREN, 0)
        def expr_bool(self):
            return self.getTypedRuleContext(ccedilhaParser.Expr_boolContext,0)

        def RPAREN(self):
            return self.getToken(ccedilhaParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_boolParen" ):
                listener.enterExpr_boolParen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_boolParen" ):
                listener.exitExpr_boolParen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_boolParen" ):
                return visitor.visitExpr_boolParen(self)
            else:
                return visitor.visitChildren(self)


    class BoolContext(Expr_boolContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ccedilhaParser.Expr_boolContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BOOL(self):
            return self.getToken(ccedilhaParser.BOOL, 0)
        def NOT(self):
            return self.getToken(ccedilhaParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBool" ):
                listener.enterBool(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBool" ):
                listener.exitBool(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBool" ):
                return visitor.visitBool(self)
            else:
                return visitor.visitChildren(self)


    class Expr_boolLogicContext(Expr_boolContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ccedilhaParser.Expr_boolContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def basic_logic(self):
            return self.getTypedRuleContext(ccedilhaParser.Basic_logicContext,0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ccedilhaParser.ExprContext)
            else:
                return self.getTypedRuleContext(ccedilhaParser.ExprContext,i)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(ccedilhaParser.STRING)
            else:
                return self.getToken(ccedilhaParser.STRING, i)
        def NOT(self):
            return self.getToken(ccedilhaParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_boolLogic" ):
                listener.enterExpr_boolLogic(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_boolLogic" ):
                listener.exitExpr_boolLogic(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_boolLogic" ):
                return visitor.visitExpr_boolLogic(self)
            else:
                return visitor.visitChildren(self)


    class Expr_boolAndOrContext(Expr_boolContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ccedilhaParser.Expr_boolContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr_bool(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ccedilhaParser.Expr_boolContext)
            else:
                return self.getTypedRuleContext(ccedilhaParser.Expr_boolContext,i)

        def AND(self):
            return self.getToken(ccedilhaParser.AND, 0)
        def OR(self):
            return self.getToken(ccedilhaParser.OR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_boolAndOr" ):
                listener.enterExpr_boolAndOr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_boolAndOr" ):
                listener.exitExpr_boolAndOr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_boolAndOr" ):
                return visitor.visitExpr_boolAndOr(self)
            else:
                return visitor.visitChildren(self)



    def expr_bool(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ccedilhaParser.Expr_boolContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 28
        self.enterRecursionRule(localctx, 28, self.RULE_expr_bool, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                localctx = ccedilhaParser.Expr_boolParenContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 211
                self.match(ccedilhaParser.LPAREN)
                self.state = 212
                self.expr_bool(0)
                self.state = 213
                self.match(ccedilhaParser.RPAREN)
                pass

            elif la_ == 2:
                localctx = ccedilhaParser.Expr_boolLogicContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 216
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==ccedilhaParser.NOT:
                    self.state = 215
                    self.match(ccedilhaParser.NOT)


                self.state = 220
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [ccedilhaParser.INT, ccedilhaParser.ID, ccedilhaParser.LPAREN]:
                    self.state = 218
                    self.expr(0)
                    pass
                elif token in [ccedilhaParser.STRING]:
                    self.state = 219
                    self.match(ccedilhaParser.STRING)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 222
                self.basic_logic()
                self.state = 225
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [ccedilhaParser.INT, ccedilhaParser.ID, ccedilhaParser.LPAREN]:
                    self.state = 223
                    self.expr(0)
                    pass
                elif token in [ccedilhaParser.STRING]:
                    self.state = 224
                    self.match(ccedilhaParser.STRING)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 3:
                localctx = ccedilhaParser.BoolContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 228
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==ccedilhaParser.NOT:
                    self.state = 227
                    self.match(ccedilhaParser.NOT)


                self.state = 230
                self.match(ccedilhaParser.BOOL)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 238
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,24,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = ccedilhaParser.Expr_boolAndOrContext(self, ccedilhaParser.Expr_boolContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_expr_bool)
                    self.state = 233
                    if not self.precpred(self._ctx, 4):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                    self.state = 234
                    _la = self._input.LA(1)
                    if not(_la==ccedilhaParser.AND or _la==ccedilhaParser.OR):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 235
                    self.expr_bool(5) 
                self.state = 240
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,24,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ccedilhaParser.RULE_expr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class ExprMultDivContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ccedilhaParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ccedilhaParser.ExprContext)
            else:
                return self.getTypedRuleContext(ccedilhaParser.ExprContext,i)

        def MULT(self):
            return self.getToken(ccedilhaParser.MULT, 0)
        def DIV(self):
            return self.getToken(ccedilhaParser.DIV, 0)
        def REST(self):
            return self.getToken(ccedilhaParser.REST, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprMultDiv" ):
                listener.enterExprMultDiv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprMultDiv" ):
                listener.exitExprMultDiv(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprMultDiv" ):
                return visitor.visitExprMultDiv(self)
            else:
                return visitor.visitChildren(self)


    class ExprParenContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ccedilhaParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(ccedilhaParser.LPAREN, 0)
        def expr(self):
            return self.getTypedRuleContext(ccedilhaParser.ExprContext,0)

        def RPAREN(self):
            return self.getToken(ccedilhaParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprParen" ):
                listener.enterExprParen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprParen" ):
                listener.exitExprParen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprParen" ):
                return visitor.visitExprParen(self)
            else:
                return visitor.visitChildren(self)


    class ExprPlusMinusContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ccedilhaParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ccedilhaParser.ExprContext)
            else:
                return self.getTypedRuleContext(ccedilhaParser.ExprContext,i)

        def PLUS(self):
            return self.getToken(ccedilhaParser.PLUS, 0)
        def MINUS(self):
            return self.getToken(ccedilhaParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprPlusMinus" ):
                listener.enterExprPlusMinus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprPlusMinus" ):
                listener.exitExprPlusMinus(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprPlusMinus" ):
                return visitor.visitExprPlusMinus(self)
            else:
                return visitor.visitChildren(self)


    class NumberContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ccedilhaParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INT(self):
            return self.getToken(ccedilhaParser.INT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)


    class IdContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ccedilhaParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(ccedilhaParser.ID, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterId" ):
                listener.enterId(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitId" ):
                listener.exitId(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitId" ):
                return visitor.visitId(self)
            else:
                return visitor.visitChildren(self)


    class ExprFuncCallContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ccedilhaParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def func_call(self):
            return self.getTypedRuleContext(ccedilhaParser.Func_callContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprFuncCall" ):
                listener.enterExprFuncCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprFuncCall" ):
                listener.exitExprFuncCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprFuncCall" ):
                return visitor.visitExprFuncCall(self)
            else:
                return visitor.visitChildren(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ccedilhaParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 30
        self.enterRecursionRule(localctx, 30, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                localctx = ccedilhaParser.NumberContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 242
                self.match(ccedilhaParser.INT)
                pass

            elif la_ == 2:
                localctx = ccedilhaParser.IdContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 243
                self.match(ccedilhaParser.ID)
                pass

            elif la_ == 3:
                localctx = ccedilhaParser.ExprFuncCallContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 244
                self.func_call()
                pass

            elif la_ == 4:
                localctx = ccedilhaParser.ExprParenContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 245
                self.match(ccedilhaParser.LPAREN)
                self.state = 246
                self.expr(0)
                self.state = 247
                self.match(ccedilhaParser.RPAREN)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 259
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,27,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 257
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
                    if la_ == 1:
                        localctx = ccedilhaParser.ExprMultDivContext(self, ccedilhaParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 251
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 252
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ccedilhaParser.MULT) | (1 << ccedilhaParser.DIV) | (1 << ccedilhaParser.REST))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 253
                        self.expr(7)
                        pass

                    elif la_ == 2:
                        localctx = ccedilhaParser.ExprPlusMinusContext(self, ccedilhaParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 254
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 255
                        _la = self._input.LA(1)
                        if not(_la==ccedilhaParser.PLUS or _la==ccedilhaParser.MINUS):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 256
                        self.expr(6)
                        pass

             
                self.state = 261
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,27,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[14] = self.expr_bool_sempred
        self._predicates[15] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_bool_sempred(self, localctx:Expr_boolContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 4)
         

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 5)
         




